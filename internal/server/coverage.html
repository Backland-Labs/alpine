
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Backland-Labs/alpine/internal/server/handlers.go (72.9%)</option>
				
				<option value="file1">github.com/Backland-Labs/alpine/internal/server/models.go (89.7%)</option>
				
				<option value="file2">github.com/Backland-Labs/alpine/internal/server/server.go (86.0%)</option>
				
				<option value="file3">github.com/Backland-Labs/alpine/internal/server/workflow_integration.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package server

import (
        "encoding/json"
        "fmt"
        "net/http"
        "time"
        
        "github.com/Backland-Labs/alpine/internal/logger"
)

// Common constants for handlers
const (
        contentTypeJSON = "application/json"
        errorFieldName  = "error"
)

// healthHandler responds to health check requests
func (s *Server) healthHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                s.respondWithError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>
        
        <span class="cov8" title="1">w.Header().Set("Content-Type", contentTypeJSON)
        response := map[string]string{
                "status": "healthy",
                "service": "alpine-server",
                "timestamp": time.Now().Format(time.RFC3339),
        }
        
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to encode health response: %v", err)
        }</span>
}

// agentsListHandler returns the list of available agents (hardcoded for MVP)
func (s *Server) agentsListHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                s.respondWithError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>
        
        // Hardcoded agent list for MVP
        <span class="cov8" title="1">agents := []Agent{
                {
                        ID:          "alpine-agent",
                        Name:        "Alpine Workflow Agent",
                        Description: "Default agent for running Alpine workflows from GitHub issues",
                },
        }
        
        w.Header().Set("Content-Type", contentTypeJSON)
        if err := json.NewEncoder(w).Encode(agents); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to encode agents list: %v", err)
        }</span>
}

// agentsRunHandler starts a new workflow run from a GitHub issue
func (s *Server) agentsRunHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                s.respondWithError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>
        
        <span class="cov8" title="1">var payload struct {
                IssueURL string `json:"issue_url"`
                AgentID  string `json:"agent_id"`
        }
        
        if err := json.NewDecoder(r.Body).Decode(&amp;payload); err != nil </span><span class="cov8" title="1">{
                logger.Infof("Invalid JSON payload in agentsRunHandler: %v", err)
                s.respondWithError(w, http.StatusBadRequest, "Invalid JSON payload")
                return
        }</span>
        
        // Validate payload
        <span class="cov8" title="1">if payload.IssueURL == "" </span><span class="cov0" title="0">{
                s.respondWithError(w, http.StatusBadRequest, "issue_url is required")
                return
        }</span>
        <span class="cov8" title="1">if payload.AgentID == "" </span><span class="cov0" title="0">{
                s.respondWithError(w, http.StatusBadRequest, "agent_id is required")
                return
        }</span>
        
        // Create new run
        <span class="cov8" title="1">run := &amp;Run{
                ID:      GenerateID("run"),
                AgentID: payload.AgentID,
                Status:  "running",
                Issue:   payload.IssueURL,
                Created: time.Now(),
                Updated: time.Now(),
        }
        
        // Store run
        s.mu.Lock()
        s.runs[run.ID] = run
        s.mu.Unlock()
        
        // Start workflow if engine is available
        if s.workflowEngine != nil </span><span class="cov8" title="1">{
                worktreeDir, err := s.workflowEngine.StartWorkflow(r.Context(), payload.IssueURL, run.ID)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Errorf("Failed to start workflow for run %s: %v", run.ID, err)
                        // Update run status to failed
                        s.updateRunStatus(run, "failed", "")
                }</span> else<span class="cov8" title="1"> {
                        logger.Infof("Workflow started for run %s in directory: %s", run.ID, worktreeDir)
                        // Update run with worktree directory
                        s.updateRunStatus(run, run.Status, worktreeDir)
                }</span>
        } else<span class="cov8" title="1"> {
                logger.Infof("Workflow engine not available, run %s created without execution", run.ID)
        }</span>
        
        <span class="cov8" title="1">w.Header().Set("Content-Type", contentTypeJSON)
        w.WriteHeader(http.StatusCreated)
        if err := json.NewEncoder(w).Encode(run); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to encode run response: %v", err)
        }</span>
}

// runsListHandler returns all runs from in-memory store
func (s *Server) runsListHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                s.respondWithError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>
        
        <span class="cov8" title="1">s.mu.Lock()
        runs := make([]Run, 0, len(s.runs))
        for _, run := range s.runs </span><span class="cov8" title="1">{
                runs = append(runs, *run)
        }</span>
        <span class="cov8" title="1">s.mu.Unlock()
        
        w.Header().Set("Content-Type", contentTypeJSON)
        if err := json.NewEncoder(w).Encode(runs); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to encode runs list: %v", err)
        }</span>
}

// runDetailsHandler returns details for a specific run
func (s *Server) runDetailsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                s.respondWithError(w, http.StatusMethodNotAllowed, "Method not allowed")
                return
        }</span>
        
        <span class="cov8" title="1">runID := r.PathValue("id")
        if runID == "" </span><span class="cov0" title="0">{
                s.respondWithError(w, http.StatusBadRequest, "Run ID is required")
                return
        }</span>
        
        <span class="cov8" title="1">s.mu.Lock()
        run, exists := s.runs[runID]
        s.mu.Unlock()
        
        if !exists </span><span class="cov8" title="1">{
                s.respondWithError(w, http.StatusNotFound, "Run not found")
                return
        }</span>
        
        // Create response with run details
        <span class="cov8" title="1">response := map[string]interface{}{
                "id":        run.ID,
                "agent_id":  run.AgentID,
                "status":    run.Status,
                "issue":     run.Issue,
                "created":   run.Created,
                "updated":   run.Updated,
                "worktree_dir": run.WorktreeDir,
        }
        
        // Add workflow state if available
        if s.workflowEngine != nil </span><span class="cov8" title="1">{
                if state, err := s.workflowEngine.GetWorkflowState(r.Context(), runID); err == nil </span><span class="cov8" title="1">{
                        response["current_step"] = state.CurrentStepDescription
                        // Update run status based on workflow state
                        if state.Status == "completed" </span><span class="cov0" title="0">{
                                s.mu.Lock()
                                run.Status = "completed"
                                run.Updated = time.Now()
                                s.mu.Unlock()
                        }</span>
                }
        }
        
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

// runEventsHandler provides SSE endpoint for run-specific events
func (s *Server) runEventsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>
        
        <span class="cov8" title="1">runID := r.PathValue("id")
        
        s.mu.Lock()
        _, exists := s.runs[runID]
        s.mu.Unlock()
        
        if !exists </span><span class="cov0" title="0">{
                http.Error(w, "Run not found", http.StatusNotFound)
                return
        }</span>
        
        // Set SSE headers
        <span class="cov8" title="1">w.Header().Set("Content-Type", "text/event-stream")
        w.Header().Set("Cache-Control", "no-cache")
        w.Header().Set("Connection", "keep-alive")
        w.Header().Set("Access-Control-Allow-Origin", "*")
        
        flusher, ok := w.(http.Flusher)
        if !ok </span><span class="cov0" title="0">{
                http.Error(w, "Streaming unsupported", http.StatusInternalServerError)
                return
        }</span>
        
        // Send initial connection event
        <span class="cov8" title="1">fmt.Fprintf(w, "data: {\"type\":\"connected\",\"runId\":\"%s\"}\n\n", runID)
        flusher.Flush()
        
        // Subscribe to workflow events if engine is available
        if s.workflowEngine != nil </span><span class="cov8" title="1">{
                events, err := s.workflowEngine.SubscribeToEvents(r.Context(), runID)
                if err == nil </span><span class="cov8" title="1">{
                        // Forward events to SSE client
                        for </span><span class="cov8" title="1">{
                                select </span>{
                                case event, ok := &lt;-events:<span class="cov8" title="1">
                                        if !ok </span><span class="cov8" title="1">{
                                                return // Channel closed
                                        }</span>
                                        // Send event as SSE
                                        <span class="cov8" title="1">data, _ := json.Marshal(event)
                                        fmt.Fprintf(w, "event: %s\ndata: %s\n\n", event.Type, string(data))
                                        flusher.Flush()</span>
                                case &lt;-r.Context().Done():<span class="cov0" title="0">
                                        return</span> // Client disconnected
                                }
                        }
                }
        }
        
        // Keep connection open until client disconnects
        <span class="cov8" title="1">&lt;-r.Context().Done()</span>
}

// runCancelHandler cancels a running workflow
func (s *Server) runCancelHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>
        
        <span class="cov8" title="1">runID := r.PathValue("id")
        
        s.mu.Lock()
        run, exists := s.runs[runID]
        if exists &amp;&amp; run.Status != "running" </span><span class="cov8" title="1">{
                s.mu.Unlock()
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusBadRequest)
                json.NewEncoder(w).Encode(map[string]string{
                        "error": "Cannot cancel non-running workflow",
                })
                return
        }</span>
        <span class="cov8" title="1">s.mu.Unlock()
        
        if !exists </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusNotFound)
                json.NewEncoder(w).Encode(map[string]string{
                        "error": "Run not found",
                })
                return
        }</span>
        
        // Cancel workflow if engine is available
        <span class="cov8" title="1">if s.workflowEngine != nil </span><span class="cov8" title="1">{
                if err := s.workflowEngine.CancelWorkflow(r.Context(), runID); err != nil </span><span class="cov0" title="0">{
                        w.Header().Set("Content-Type", "application/json")
                        w.WriteHeader(http.StatusInternalServerError)
                        json.NewEncoder(w).Encode(map[string]string{
                                "error": "Failed to cancel workflow",
                        })
                        return
                }</span>
        }
        
        // Update run status
        <span class="cov8" title="1">s.mu.Lock()
        run.Status = "cancelled"
        run.Updated = time.Now()
        s.mu.Unlock()
        
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{
                "status": "cancelled",
                "runId":  runID,
        })</span>
}

// planGetHandler retrieves plan content for a run
func (s *Server) planGetHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>
        
        <span class="cov8" title="1">runID := r.PathValue("runId")
        
        s.mu.Lock()
        plan, exists := s.plans[runID]
        s.mu.Unlock()
        
        if !exists </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusNotFound)
                json.NewEncoder(w).Encode(map[string]string{
                        "error": "Plan not found",
                })
                return
        }</span>
        
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(plan)</span>
}

// planApproveHandler approves a plan to continue workflow
func (s *Server) planApproveHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>
        
        <span class="cov8" title="1">runID := r.PathValue("runId")
        
        s.mu.Lock()
        plan, exists := s.plans[runID]
        run, runExists := s.runs[runID]
        s.mu.Unlock()
        
        if !exists </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusNotFound)
                json.NewEncoder(w).Encode(map[string]string{
                        "error": "Plan not found",
                })
                return
        }</span>
        
        // Approve plan in workflow engine
        <span class="cov8" title="1">if s.workflowEngine != nil </span><span class="cov8" title="1">{
                if err := s.workflowEngine.ApprovePlan(r.Context(), runID); err != nil </span><span class="cov8" title="1">{
                        w.Header().Set("Content-Type", "application/json")
                        w.WriteHeader(http.StatusInternalServerError)
                        json.NewEncoder(w).Encode(map[string]string{
                                "error": "Failed to approve plan",
                        })
                        return
                }</span>
        }
        
        // Update plan status only after successful workflow approval
        <span class="cov8" title="1">s.mu.Lock()
        plan.Status = "approved"
        plan.Updated = time.Now()
        // Update run status
        if runExists </span><span class="cov8" title="1">{
                run.Status = "running"
                run.Updated = time.Now()
        }</span>
        <span class="cov8" title="1">s.mu.Unlock()
        
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{
                "status": "approved",
                "runId":  runID,
        })</span>
}

// planFeedbackHandler handles feedback on a plan
func (s *Server) planFeedbackHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>
        
        <span class="cov8" title="1">runID := r.PathValue("runId")
        
        s.mu.Lock()
        _, exists := s.plans[runID]
        s.mu.Unlock()
        
        if !exists </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusNotFound)
                json.NewEncoder(w).Encode(map[string]string{
                        "error": "Plan not found",
                })
                return
        }</span>
        
        <span class="cov8" title="1">var payload struct {
                Feedback string `json:"feedback"`
        }
        
        if err := json.NewDecoder(r.Body).Decode(&amp;payload); err != nil </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusBadRequest)
                json.NewEncoder(w).Encode(map[string]string{
                        "error": "Invalid JSON payload",
                })
                return
        }</span>
        
        // TODO: Process feedback and regenerate plan
        
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{
                "status": "feedback_received",
                "runId":  runID,
        })</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">// Package server implements REST API data models for Alpine's HTTP server.
// These models represent agents, workflow runs, and plans used in the API.
package server

import (
        "crypto/rand"
        "encoding/hex"
        "errors"
        "fmt"
        "time"
)

// Status constants for Run
const (
        StatusRunning   = "running"
        StatusCompleted = "completed"
        StatusCancelled = "cancelled"
        StatusFailed    = "failed"
)

// Status constants for Plan
const (
        PlanStatusPending  = "pending"
        PlanStatusApproved = "approved"
        PlanStatusRejected = "rejected"
)

// Validation errors
var (
        ErrEmptyID           = errors.New("ID cannot be empty")
        ErrEmptyName         = errors.New("name cannot be empty")
        ErrEmptyRunID        = errors.New("run ID cannot be empty")
        ErrEmptyContent      = errors.New("content cannot be empty")
        ErrInvalidStatus     = errors.New("invalid status")
        ErrInvalidTransition = errors.New("invalid status transition")
)

// Agent represents an AI agent available for workflow execution.
// Agents are the primary abstraction for different types of automation tasks.
type Agent struct {
        ID          string `json:"id"`
        Name        string `json:"name"`
        Description string `json:"description"`
}

// Validate checks if the Agent has all required fields properly set.
func (a *Agent) Validate() error <span class="cov8" title="1">{
        if a.ID == "" </span><span class="cov8" title="1">{
                return ErrEmptyID
        }</span>
        <span class="cov8" title="1">if a.Name == "" </span><span class="cov8" title="1">{
                return ErrEmptyName
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Run represents a workflow execution instance.
// Each run is associated with an agent and tracks the lifecycle of a workflow.
type Run struct {
        ID          string    `json:"id"`
        AgentID     string    `json:"agent_id"`
        Status      string    `json:"status"` // running, completed, cancelled, failed
        Issue       string    `json:"issue"`
        Created     time.Time `json:"created"`
        Updated     time.Time `json:"updated"`
        WorktreeDir string    `json:"worktree_dir,omitempty"`
}

// Validate checks if the Run has all required fields properly set.
func (r *Run) Validate() error <span class="cov8" title="1">{
        if r.ID == "" </span><span class="cov8" title="1">{
                return ErrEmptyID
        }</span>
        <span class="cov8" title="1">if r.AgentID == "" </span><span class="cov0" title="0">{
                return errors.New("agent ID cannot be empty")
        }</span>
        <span class="cov8" title="1">if !r.IsValidStatus() </span><span class="cov8" title="1">{
                return ErrInvalidStatus
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// IsValidStatus checks if the current status is a valid run status.
func (r *Run) IsValidStatus() bool <span class="cov8" title="1">{
        switch r.Status </span>{
        case StatusRunning, StatusCompleted, StatusCancelled, StatusFailed:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// CanTransitionTo checks if the run can transition from its current status to the target status.
func (r *Run) CanTransitionTo(targetStatus string) bool <span class="cov8" title="1">{
        // Only running status can transition to other states
        if r.Status != StatusRunning </span><span class="cov8" title="1">{
                return false
        }</span>

        // Running can transition to completed, cancelled, or failed
        <span class="cov8" title="1">switch targetStatus </span>{
        case StatusCompleted, StatusCancelled, StatusFailed:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// Plan represents a workflow execution plan that can be approved or rejected.
// Plans are generated for workflows and require user approval before execution.
type Plan struct {
        RunID   string    `json:"run_id"`
        Content string    `json:"content"`
        Status  string    `json:"status"` // pending, approved, rejected
        Created time.Time `json:"created"`
        Updated time.Time `json:"updated"`
}

// Validate checks if the Plan has all required fields properly set.
func (p *Plan) Validate() error <span class="cov8" title="1">{
        if p.RunID == "" </span><span class="cov8" title="1">{
                return ErrEmptyRunID
        }</span>
        <span class="cov8" title="1">if p.Content == "" </span><span class="cov8" title="1">{
                return ErrEmptyContent
        }</span>
        <span class="cov8" title="1">if !p.IsValidStatus() </span><span class="cov8" title="1">{
                return ErrInvalidStatus
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// IsValidStatus checks if the current status is a valid plan status.
func (p *Plan) IsValidStatus() bool <span class="cov8" title="1">{
        switch p.Status </span>{
        case PlanStatusPending, PlanStatusApproved, PlanStatusRejected:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// CanTransitionTo checks if the plan can transition from its current status to the target status.
func (p *Plan) CanTransitionTo(targetStatus string) bool <span class="cov8" title="1">{
        // Only pending status can transition to other states
        if p.Status != PlanStatusPending </span><span class="cov8" title="1">{
                return false
        }</span>

        // Pending can transition to approved or rejected
        <span class="cov8" title="1">switch targetStatus </span>{
        case PlanStatusApproved, PlanStatusRejected:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// GenerateID creates a unique identifier for use in runs and other resources.
// It generates a cryptographically secure random hex string prefixed with the resource type.
func GenerateID(prefix string) string <span class="cov8" title="1">{
        bytes := make([]byte, 8)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                // Fallback to timestamp-based ID if random generation fails
                return fmt.Sprintf("%s-%d", prefix, time.Now().UnixNano())
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s-%s", prefix, hex.EncodeToString(bytes))</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package server implements an HTTP server with Server-Sent Events (SSE) support
// for Alpine. This server allows frontend applications to receive real-time
// updates about workflow progress and state changes.
package server

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net"
        "net/http"
        "sync"
        "time"
)

// Constants for server configuration
const (
        // defaultEventBufferSize is the default size for the events channel buffer
        defaultEventBufferSize = 100
)

// Common errors returned by the server
var (
        // ErrServerRunning is returned when attempting to start an already running server
        ErrServerRunning = errors.New("server is already running")
)

// Server represents an HTTP server with Server-Sent Events support.
// It provides real-time updates to connected clients about Alpine's
// workflow progress and state changes.
type Server struct {
        port       int          // Port number to listen on (0 for auto-assignment)
        httpServer *http.Server // Underlying HTTP server instance
        eventsChan chan string  // Channel for broadcasting events to clients
        listener   net.Listener // Network listener for accepting connections
        mu         sync.Mutex   // Protects server state during concurrent access
        running    bool         // Indicates if the server is currently running
        
        // In-memory storage for REST API
        runs  map[string]*Run  // Storage for workflow runs
        plans map[string]*Plan // Storage for workflow plans
        
        // Workflow engine integration
        workflowEngine WorkflowEngine // Optional workflow engine for executing workflows
}

// NewServer creates a new HTTP server instance configured to run on the specified port.
// The server is initialized but not started - use Start() to begin listening.
func NewServer(port int) *Server <span class="cov8" title="1">{
        mux := http.NewServeMux()

        return &amp;Server{
                port: port,
                httpServer: &amp;http.Server{
                        Addr:    fmt.Sprintf("localhost:%d", port),
                        Handler: mux,
                },
                eventsChan: make(chan string, defaultEventBufferSize),
                runs:       make(map[string]*Run),
                plans:      make(map[string]*Plan),
        }
}</span>

// Start begins listening for HTTP requests on the configured port.
// The server runs until the provided context is canceled.
// Returns http.ErrServerClosed on graceful shutdown, or any other error if startup fails.
func (s *Server) Start(ctx context.Context) error <span class="cov8" title="1">{
        s.mu.Lock()
        if s.running </span><span class="cov0" title="0">{
                s.mu.Unlock()
                return ErrServerRunning
        }</span>
        <span class="cov8" title="1">s.running = true
        s.mu.Unlock()

        // Check if context is already canceled
        select </span>{
        case &lt;-ctx.Done():<span class="cov8" title="1">
                s.mu.Lock()
                s.running = false
                s.mu.Unlock()
                return ctx.Err()</span>
        default:<span class="cov8" title="1"></span>
        }

        // Create listener with dynamic address for reuse
        <span class="cov8" title="1">addr := s.httpServer.Addr
        if s.port == 0 </span><span class="cov8" title="1">{
                addr = "localhost:0" // Let OS assign port
        }</span>

        <span class="cov8" title="1">var err error
        s.listener, err = net.Listen("tcp", addr)
        if err != nil </span><span class="cov0" title="0">{
                s.mu.Lock()
                s.running = false
                s.mu.Unlock()
                return fmt.Errorf("failed to listen: %w", err)
        }</span>

        // Create a new HTTP server for each start to avoid reuse issues
        <span class="cov8" title="1">mux := http.NewServeMux()

        // Register endpoint handlers
        mux.HandleFunc("/events", s.sseHandler)
        mux.HandleFunc("/health", s.healthHandler)
        mux.HandleFunc("/agents/list", s.agentsListHandler)
        mux.HandleFunc("/agents/run", s.agentsRunHandler)
        mux.HandleFunc("/runs", s.runsListHandler)
        mux.HandleFunc("/runs/{id}", s.runDetailsHandler)
        mux.HandleFunc("/runs/{id}/events", s.runEventsHandler)
        mux.HandleFunc("/runs/{id}/cancel", s.runCancelHandler)
        mux.HandleFunc("/plans/{runId}", s.planGetHandler)
        mux.HandleFunc("/plans/{runId}/approve", s.planApproveHandler)
        mux.HandleFunc("/plans/{runId}/feedback", s.planFeedbackHandler)

        s.httpServer = &amp;http.Server{
                Handler: mux,
        }

        // Handle shutdown when context is canceled
        go func() </span><span class="cov8" title="1">{
                &lt;-ctx.Done()
                _ = s.httpServer.Shutdown(context.Background())
        }</span>()

        // Start serving
        <span class="cov8" title="1">err = s.httpServer.Serve(s.listener)

        s.mu.Lock()
        s.running = false
        s.listener = nil
        s.mu.Unlock()

        // http.ErrServerClosed is expected when shutting down gracefully
        if err == http.ErrServerClosed </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov0" title="0">return err</span>
}

// Address returns the actual address the server is listening on.
// Returns empty string if the server is not running.
func (s *Server) Address() string <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.listener == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return s.listener.Addr().String()</span>
}

// SetWorkflowEngine sets the workflow engine for the server
func (s *Server) SetWorkflowEngine(engine WorkflowEngine) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.workflowEngine = engine
}</span>

// BroadcastEvent broadcasts a workflow event to all connected SSE clients
func (s *Server) BroadcastEvent(event WorkflowEvent) <span class="cov8" title="1">{
        // Convert event to JSON for SSE
        data, err := json.Marshal(event)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        // Create SSE formatted message
        <span class="cov8" title="1">message := fmt.Sprintf("event: %s\ndata: %s\n\n", event.Type, string(data))
        
        // Send to event channel (non-blocking)
        select </span>{
        case s.eventsChan &lt;- message:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0"></span>
                // Channel full, drop message
        }
}

// sseHandler handles Server-Sent Events connections at the /events endpoint.
// It sends an initial "hello world" event upon connection and manages the
// client lifecycle, including proper cleanup on disconnect.
func (s *Server) sseHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Set SSE specific headers
        w.Header().Set("Content-Type", "text/event-stream")
        w.Header().Set("Cache-Control", "no-cache")
        w.Header().Set("Connection", "keep-alive")
        w.Header().Set("Access-Control-Allow-Origin", "*")

        // Ensure buffering is disabled for real-time updates
        flusher, ok := w.(http.Flusher)
        if !ok </span><span class="cov0" title="0">{
                http.Error(w, "Streaming unsupported", http.StatusInternalServerError)
                return
        }</span>

        // Send initial hello world event
        <span class="cov8" title="1">_, _ = fmt.Fprintf(w, "data: hello world\n\n")
        flusher.Flush()

        // Listen for events from the event channel
        for </span><span class="cov8" title="1">{
                select </span>{
                case event := &lt;-s.eventsChan:<span class="cov8" title="1">
                        // Send event to client
                        _, _ = fmt.Fprint(w, event)
                        flusher.Flush()</span>
                case &lt;-r.Context().Done():<span class="cov8" title="1">
                        // Client disconnected
                        return</span>
                }
        }
}

// Helper methods

// respondWithError sends a JSON error response with the specified status code
func (s *Server) respondWithError(w http.ResponseWriter, statusCode int, message string) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        response := map[string]string{
                "error": message,
        }
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                // Log the error but don't attempt to write more to the response
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// updateRunStatus updates a run's status and worktree directory in a thread-safe manner
func (s *Server) updateRunStatus(run *Run, status string, worktreeDir string) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        
        run.Status = status
        run.Updated = time.Now()
        if worktreeDir != "" </span><span class="cov8" title="1">{
                run.WorktreeDir = worktreeDir
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package server provides HTTP server functionality for Alpine, including
// workflow integration and REST API endpoints.
package server

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "sync"
        "time"

        "github.com/Backland-Labs/alpine/internal/config"
        "github.com/Backland-Labs/alpine/internal/core"
        "github.com/Backland-Labs/alpine/internal/gitx"
        "github.com/Backland-Labs/alpine/internal/logger"
        "github.com/Backland-Labs/alpine/internal/workflow"
)

const (
        // defaultEventChannelSize is the buffer size for workflow event channels
        defaultEventChannelSize = 100
        
        // worktreeNamePrefix is the prefix for worktree directory names
        worktreeNamePrefix = "run-"
        
        // tempDirPrefix is the prefix for temporary workflow directories
        tempDirPrefix = "alpine-run-"
        
        // stateFileRelativePath is the relative path for state files within workflow directories
        stateFileRelativePath = "agent_state/agent_state.json"
)

// AlpineWorkflowEngine is the concrete implementation that wraps Alpine's workflow.Engine
// to provide REST API integration with workflow execution. It manages multiple concurrent
// workflow instances and provides event streaming capabilities.
type AlpineWorkflowEngine struct {
        claudeExecutor workflow.ClaudeExecutor
        wtMgr          gitx.WorktreeManager
        cfg            *config.Config
        
        // Track active workflows with thread-safe access
        mu        sync.RWMutex
        workflows map[string]*workflowInstance
}

// workflowInstance tracks a single workflow execution with its associated
// resources and event stream.
type workflowInstance struct {
        engine      *workflow.Engine    // The workflow engine instance
        ctx         context.Context      // Workflow-specific context for cancellation
        cancel      context.CancelFunc   // Function to cancel the workflow
        events      chan WorkflowEvent   // Channel for broadcasting workflow events
        worktreeDir string               // Directory containing workflow files
        stateFile   string               // Path to the workflow state file
        createdAt   time.Time           // Timestamp when the workflow was created
}

// NewAlpineWorkflowEngine creates a new workflow engine integration.
// It initializes the engine with the provided Claude executor, worktree manager,
// and configuration.
func NewAlpineWorkflowEngine(executor workflow.ClaudeExecutor, wtMgr gitx.WorktreeManager, cfg *config.Config) *AlpineWorkflowEngine <span class="cov0" title="0">{
        logger.Debugf("Creating new Alpine workflow engine")
        return &amp;AlpineWorkflowEngine{
                claudeExecutor: executor,
                wtMgr:          wtMgr,
                cfg:            cfg,
                workflows:      make(map[string]*workflowInstance),
        }
}</span>

// StartWorkflow initiates a new workflow run with the given GitHub issue URL.
// It creates an isolated environment (worktree or temporary directory) for the workflow
// and starts execution in the background. Returns the workflow directory path.
func (e *AlpineWorkflowEngine) StartWorkflow(ctx context.Context, issueURL string, runID string) (string, error) <span class="cov0" title="0">{
        logger.Infof("Starting workflow %s for issue: %s", runID, issueURL)
        
        e.mu.Lock()
        defer e.mu.Unlock()
        
        // Check if workflow already exists
        if _, exists := e.workflows[runID]; exists </span><span class="cov0" title="0">{
                logger.Infof("Attempted to start duplicate workflow: %s", runID)
                return "", fmt.Errorf("workflow %s already exists", runID)
        }</span>
        
        // Create workflow context
        <span class="cov0" title="0">workflowCtx, cancel := context.WithCancel(ctx)
        
        // Create custom config for this workflow
        workflowCfg := *e.cfg // Copy config
        
        // Create isolated directory for the workflow
        worktreeDir, err := e.createWorkflowDirectory(workflowCtx, runID, cancel)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        
        // Update state file path to be in workflow directory
        <span class="cov0" title="0">workflowCfg.StateFile = filepath.Join(worktreeDir, stateFileRelativePath)
        
        // Create workflow engine
        engine := workflow.NewEngine(e.claudeExecutor, e.wtMgr, &amp;workflowCfg)
        engine.SetStateFile(workflowCfg.StateFile)
        
        // Create workflow instance
        instance := &amp;workflowInstance{
                engine:      engine,
                ctx:         workflowCtx,
                cancel:      cancel,
                events:      make(chan WorkflowEvent, defaultEventChannelSize),
                worktreeDir: worktreeDir,
                stateFile:   workflowCfg.StateFile,
                createdAt:   time.Now(),
        }
        
        e.workflows[runID] = instance
        
        // Start workflow execution in background
        go e.runWorkflowAsync(instance, issueURL, runID)
        
        logger.Infof("Workflow %s started successfully in directory: %s", runID, worktreeDir)
        return worktreeDir, nil</span>
}

// CancelWorkflow cancels an active workflow run.
// It triggers cancellation through the workflow's context and sends a cancellation event.
func (e *AlpineWorkflowEngine) CancelWorkflow(ctx context.Context, runID string) error <span class="cov0" title="0">{
        logger.Infof("Cancelling workflow: %s", runID)
        
        e.mu.Lock()
        defer e.mu.Unlock()
        
        instance, exists := e.workflows[runID]
        if !exists </span><span class="cov0" title="0">{
                logger.Infof("Attempted to cancel non-existent workflow: %s", runID)
                return fmt.Errorf("workflow %s not found", runID)
        }</span>
        
        // Cancel the workflow context
        <span class="cov0" title="0">instance.cancel()
        
        // Send cancellation event (non-blocking)
        e.sendEventNonBlocking(instance, WorkflowEvent{
                Type:      "workflow_cancelled",
                RunID:     runID,
                Timestamp: time.Now(),
                Data:      map[string]interface{}{},
        })
        
        logger.Infof("Workflow %s cancelled successfully", runID)
        return nil</span>
}

// GetWorkflowState returns the current state of a workflow run.
// It reads the state from the workflow's state file.
func (e *AlpineWorkflowEngine) GetWorkflowState(ctx context.Context, runID string) (*core.State, error) <span class="cov0" title="0">{
        e.mu.RLock()
        defer e.mu.RUnlock()
        
        instance, exists := e.workflows[runID]
        if !exists </span><span class="cov0" title="0">{
                logger.Debugf("Workflow state requested for non-existent workflow: %s", runID)
                return nil, fmt.Errorf("workflow %s not found", runID)
        }</span>
        
        // Load state from file
        <span class="cov0" title="0">state, err := core.LoadState(instance.stateFile)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to load state for workflow %s: %v", runID, err)
                return nil, fmt.Errorf("failed to load state: %w", err)
        }</span>
        
        <span class="cov0" title="0">return state, nil</span>
}

// ApprovePlan approves a workflow plan and continues execution.
// It updates the workflow state to trigger the implementation phase.
func (e *AlpineWorkflowEngine) ApprovePlan(ctx context.Context, runID string) error <span class="cov0" title="0">{
        logger.Infof("Approving plan for workflow: %s", runID)
        
        e.mu.RLock()
        defer e.mu.RUnlock()
        
        instance, exists := e.workflows[runID]
        if !exists </span><span class="cov0" title="0">{
                logger.Infof("Attempted to approve plan for non-existent workflow: %s", runID)
                return fmt.Errorf("workflow %s not found", runID)
        }</span>
        
        // Update state to continue with implementation
        <span class="cov0" title="0">state, err := core.LoadState(instance.stateFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load state: %w", err)
        }</span>
        
        // Update state to trigger implementation
        <span class="cov0" title="0">state.CurrentStepDescription = "Plan approved, continuing implementation"
        state.NextStepPrompt = "/run_implementation_loop"
        state.Status = core.StatusRunning
        
        if err := state.Save(instance.stateFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save state: %w", err)
        }</span>
        
        // Send plan approved event (non-blocking)
        <span class="cov0" title="0">e.sendEventNonBlocking(instance, WorkflowEvent{
                Type:      "plan_approved",
                RunID:     runID,
                Timestamp: time.Now(),
                Data:      map[string]interface{}{},
        })
        
        logger.Infof("Plan approved for workflow %s", runID)
        return nil</span>
}

// SubscribeToEvents subscribes to workflow events for a specific run.
// It returns a channel that receives all events from the workflow, including
// the current state as an initial event.
func (e *AlpineWorkflowEngine) SubscribeToEvents(ctx context.Context, runID string) (&lt;-chan WorkflowEvent, error) <span class="cov0" title="0">{
        logger.Debugf("New event subscription for workflow: %s", runID)
        
        e.mu.RLock()
        defer e.mu.RUnlock()
        
        instance, exists := e.workflows[runID]
        if !exists </span><span class="cov0" title="0">{
                logger.Infof("Event subscription requested for non-existent workflow: %s", runID)
                return nil, fmt.Errorf("workflow %s not found", runID)
        }</span>
        
        // Create a new channel for this subscriber
        <span class="cov0" title="0">subscriber := make(chan WorkflowEvent, defaultEventChannelSize)
        
        // Forward events from the workflow to the subscriber
        go func() </span><span class="cov0" title="0">{
                defer close(subscriber)
                
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case event, ok := &lt;-instance.events:<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">select </span>{
                                case subscriber &lt;- event:<span class="cov0" title="0"></span>
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                }
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()
        
        // Send current state as an event
        <span class="cov0" title="0">if state, err := e.GetWorkflowState(ctx, runID); err == nil </span><span class="cov0" title="0">{
                select </span>{
                case subscriber &lt;- WorkflowEvent{
                        Type:      "state_changed",
                        RunID:     runID,
                        Timestamp: time.Now(),
                        Data: map[string]interface{}{
                                "status":       state.Status,
                                "current_step": state.CurrentStepDescription,
                        },
                }:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0"></span>
                }
        }
        
        <span class="cov0" title="0">return subscriber, nil</span>
}

// Cleanup removes completed workflows from memory.
// It cancels the workflow context and removes it from the active workflows map.
func (e *AlpineWorkflowEngine) Cleanup(runID string) <span class="cov0" title="0">{
        logger.Debugf("Cleaning up workflow: %s", runID)
        
        e.mu.Lock()
        defer e.mu.Unlock()
        
        if instance, exists := e.workflows[runID]; exists </span><span class="cov0" title="0">{
                instance.cancel()
                delete(e.workflows, runID)
                logger.Infof("Workflow %s cleaned up after %.2f minutes", runID, time.Since(instance.createdAt).Minutes())
        }</span>
}

// Helper methods

// createWorkflowDirectory creates an isolated directory for workflow execution.
// It uses a worktree if available and enabled, otherwise creates a temporary directory.
func (e *AlpineWorkflowEngine) createWorkflowDirectory(ctx context.Context, runID string, cancel context.CancelFunc) (string, error) <span class="cov0" title="0">{
        if e.wtMgr != nil &amp;&amp; e.cfg.Git.WorktreeEnabled </span><span class="cov0" title="0">{
                // Create worktree for the workflow
                worktreeName := fmt.Sprintf("%s%s", worktreeNamePrefix, runID)
                wt, err := e.wtMgr.Create(ctx, worktreeName)
                if err != nil </span><span class="cov0" title="0">{
                        cancel()
                        logger.Errorf("Failed to create worktree for workflow %s: %v", runID, err)
                        return "", fmt.Errorf("failed to create worktree: %w", err)
                }</span>
                <span class="cov0" title="0">logger.Infof("Created worktree for workflow %s at: %s", runID, wt.Path)
                return wt.Path, nil</span>
        }
        
        // Use temporary directory for state
        <span class="cov0" title="0">tempDirName := fmt.Sprintf("%s%s-", tempDirPrefix, runID)
        tempDir, err := os.MkdirTemp("", tempDirName)
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                logger.Errorf("Failed to create temp directory for workflow %s: %v", runID, err)
                return "", fmt.Errorf("failed to create temp directory: %w", err)
        }</span>
        <span class="cov0" title="0">logger.Infof("Created temporary directory for workflow %s at: %s", runID, tempDir)
        return tempDir, nil</span>
}

// runWorkflowAsync executes the workflow in a goroutine and manages event broadcasting.
func (e *AlpineWorkflowEngine) runWorkflowAsync(instance *workflowInstance, issueURL string, runID string) <span class="cov0" title="0">{
        defer close(instance.events)
        
        // Send start event
        instance.events &lt;- WorkflowEvent{
                Type:      "workflow_started",
                RunID:     runID,
                Timestamp: time.Now(),
                Data: map[string]interface{}{
                        "issue": issueURL,
                        "worktree_dir": instance.worktreeDir,
                },
        }
        
        // Run the workflow
        logger.Infof("Executing workflow %s", runID)
        err := instance.engine.Run(instance.ctx, issueURL, true) // Generate plan by default
        
        // Send completion event
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Workflow %s failed: %v", runID, err)
                instance.events &lt;- WorkflowEvent{
                        Type:      "workflow_failed",
                        RunID:     runID,
                        Timestamp: time.Now(),
                        Data: map[string]interface{}{
                                "error": err.Error(),
                        },
                }
        }</span> else<span class="cov0" title="0"> {
                logger.Infof("Workflow %s completed successfully", runID)
                instance.events &lt;- WorkflowEvent{
                        Type:      "workflow_completed",
                        RunID:     runID,
                        Timestamp: time.Now(),
                        Data:      map[string]interface{}{},
                }
        }</span>
}

// sendEventNonBlocking attempts to send an event to the workflow's event channel.
// If the channel is full or closed, the event is dropped and a warning is logged.
func (e *AlpineWorkflowEngine) sendEventNonBlocking(instance *workflowInstance, event WorkflowEvent) <span class="cov0" title="0">{
        select </span>{
        case instance.events &lt;- event:<span class="cov0" title="0">
                logger.Debugf("Event sent for workflow %s: %s", event.RunID, event.Type)</span>
        default:<span class="cov0" title="0">
                // Event channel might be full or closed
                logger.Infof("Failed to send event for workflow %s: channel full or closed", event.RunID)</span>
        }
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
